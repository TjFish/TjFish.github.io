---
title: 面试题目总结
date: 2021-06-08
categories: [学习]
tags: [面试]  
img_path: /assets/img/
---

本文主要是为了总结记录下我的秋招之路，毕竟现在才发面经，也太特么晚了吧。当然，如果能为他人提供哪怕微微的帮助，我也会非常高兴。先做自我介绍，研究生，方向Java开发，无实习，无项目，无获奖，无竞赛，成绩差，基础差，准备时间晚，真菜得一笔，仅有的优势就是学历还行，起码不会被卡学历。另外，心态好，学习能力强，面经看得多，个人总结到位了。最后的结果超出预期的好，毕竟我的预期只是年薪三十万，达到街薪即可。行文主要分为三个部分：个人历程、基础面经总结以及手撕代码总结。 

作者：渺万里层云.

原文链接：

https://www.nowcoder.com/discuss/344311?type=2&order=0&pos=18&page=5&channel=666&source_id=discuss_tag

来源：牛客网


 	**个人历程**  

 	首先，我犯了一个极其严重的错误，那就是准备的太晚，没敢参加提前批，好多公司提前批都已经招得差不多了，正式批hc太少了。其次，实验室不让实习，没有实习经历，也没有可深谈的项目，太不利于秋招了。室友都是微软实习转正，太羡慕嫉妒了。我时常在想，如果我曾实习过，是不是会顺利很多？  

 	我正式参加简历投递已经是九月初了。简历投了三四十，笔试做了二三十。印象深刻的有两天，其中一天堆了7个笔试，我做了5个。还有一天，4个笔试加一个面试，而且其中两个笔试是并行的。并行的意思是，贝壳宣讲会和华为笔试都是晚上7点，所以我带着笔记本去参加宣讲会， 华为笔试40分钟提前交卷，然后接着写贝壳的现场笔试。我自认为笔试做得还行，但面试真的没几个，也就京东(三面加一块不到一小时)、猿辅导(二面代码写得慢挂)、美团(二面莫名其妙挂)、bigo(一面挂， 女面试官下手太狠了)、cvte(面试自我感觉良好，然后反手被挂)、滴滴(三面因为一个非常简单的问题被挂，太特么丢人了，就不说了)。这是我国庆之前的情况，非常的失落以及慌张，感觉大厂都不怎么招人了，小厂只笔试不面试，有面试也是刷KPI的。最让我烦的是快手，我笔试全对，然后挂了。哥们听我遭遇之后，笔试干脆不做，然后快手邀他去面试，这特么跟谁说理去？这时，我甚至已经做好了春招再战的准备。  

 	我真的非常感谢字节跳动。大家都说头条早已招满，所以即使头条连续给我发两次笔试链接，我都选择了其他家的笔试。然而他们依然打电话约面试。我将我秋招最后也是最大的希望都放在了头条上。国庆期间，我在牛客网上刷了很多头条的面经，把基础题和代码题全部总结了下， 不会的全记录下来慢慢解决。其实，国庆七天也就努力了三天，后四天全玩了……国庆之后的那周，是我最努力的一周。因为，一起抱团取暖、同样苦比的哥们被头条收了，只剩我一人继续苦比了。老哥回头望，笑我还不快跟上。好吧，努力去跟上。那周，我就憋着一股气去学习，去面试，就为了通过下周一的头条面试。那周，我依次面了拼多多一面，招行三面，度小满三面，自我感觉都挺好的。在此我感谢度小满，他给了我很大的信心。度小满三面都是技术面，难度都不低，面试官人都很好。二面面试官在肯定了我之后，告诫我要注意表达，虽然技术面不怎么看注重表达能力，但第三面会考察，要注意一下。同时又指点了我个人学习要注意的一些事项。第三面面试官，嚯~~~~~~，特别漂亮的女面试官。漂亮且气质，用一个词来形容就是精致，精致的面孔，精致的发型，优雅的谈吐。而且还是个技术大拿。她给我讲了10多分钟的金融知识，在得知我无offer的慌张后，她肯定了我的水平，说我的情况拿五个完全没问题，根本不用慌。并劝告我，以后在选择offer的时候，要注重个人的发展，一定要先搞清楚自己感兴趣的方向是什么，不要什么都没弄明白就一股脑扎进去。然后就是字节跳动抖音部门的面试，三面下来，又褪了层皮，感觉再也不想面试了，心累了。度小满加抖音这两天六面，真的耗光了我所有的精力。幸运的是，第二天抖音hr就微信偷偷告诉我面试通过了，慢慢等oc吧。然后我就傲娇得拒绝了云从、奇安信、小米、贝壳的面试。抱着爱咋咋地得悠然心态，走完了拼多多、华为、有道的面试流程。  

 	嗯，最后我选择了拼多多。  

 	**基础总结**  

 	关于一面二面的基础部分，只要准备的足够充分，百分之九十的问题都能完全答对。这里面真的丝毫技术含量都没有，全靠背。在我所有的面试里，只有头条二面是靠背解决不了的，因为他总能精准找到你的知识盲区，明明这块我自认为复习的足够全面，但依然被他怼得说不出话来。即使再给我两星期时间准备，我也很难复习到他所问的那些点。但比较好的是，准备得多了，即使被抓着盲点怼，也能够现场尝试给出猜测，不管对不对，起码能体现出相关知识储备以及思考能力。关于基础知识的总结，网上有很多，最好的就是github上JavaGuide那老哥。我的建议是，将他整理的PDF打印出来，好好看好好学。最后，再按照知识点用自己的语言习惯总结一下，务必简洁扼要有序，面试的时候直接按照总结的背起就行。他总结的并不能完全覆盖所有面试点，这就需要自己去不断的看别人的面经，整理一下他人被提问的问题，对于那些不会的、说不清的又很重要的问题，去网上搜答案，看懂之后再自我总结。不断的在面试和面经中，迭代自己的知识点总结。下面我分类将我认为比较重要的问题列出来。  

##  	**网络：**  

 	1、OSI七层模型与TCP/IP 五层模型,  

 	2、常见应用层协议和运输层、网络层协议，以及硬件如路由器之类在哪一层  

 	3、TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些   （DNS， OICQ）

 	4、TCP可靠传输的保证，拥塞控制目和过程   

 	5、TCP粘包现象原因和解决方法  

 	6、TCP三次握手过程以及每次握手后的状态改变，为什么三次？为什么两次不行？如果你的答案是防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源，但这个答案被否定了，你还能给出什么答案？  

 	7、TCP四次挥手过程以及状态改变，为什么四次？CLOSE-WAIT和TIME-WAIT存在的意义？如何查看TIME-WAIT状态的链接数量？为什么会TIME-WAIT过多？解决方法是怎样的？  

 	8、TCP、UDP、IP、以太网报文格式以及重要字段，报文从一端到另一端传递的过程。  

 	9、浏览器输入URL并回车的过程以及相关协议，DNS查询过程。  

 	10、HTTP1.0、1.1、2.0之间的区别  

 	11、HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法 AES，DES 和非对称加密算法RSA（ **大整数的因式分解**）DSA？

 	12、HTTP请求有哪些，多说点。Post和get区别。  （get，post，head，put，delete，options，connect，trace

 	13、HTTP常见响应状态码，从1xx到5xx都要说。如304,301,302，504，

> 100 继续 101 切换协议   
>
> 200 OK，201 Created 202 Accepted（异步api），203  204 No Content （表示内容没更新）
>
> 301(永久移动)   302（临时移动） 304（未修改）
>
> 400 Bad Request 401 未授权 403 禁止（无权限） 404 Not Found 405 方法不允许
>
> 500 服务器内部错误 502（上游服务器Bad） 503 服务暂时不可用 504 网关超时（上游服务器超时） 505 http版本不支持

 	14、重定向和转发区别  

>重定向是客户端行为，转发是服务端行为。

 	15、cookie和session区别。  



##  	**操作系统：**  

 	1、进程和线程的区别  

 	2、协程呢？  

 	3、进程间通信方式IPC  

 	4、用户态和核心态  

 	5、操作系统分配的进程空间是怎样的？线程能共享哪些？  

 	6、操作系统内存管理方式，分页分段以及段页式的优缺点  （ MMU，TLB）

 	7、页面置换算法有哪些，FIFO为什么不好？如何改进?LRU思想，手写LRU  

（FIFO先进先出，LRU 最近最久未使用，LFU  Least Frequently  Used最少使用）

 	8、死锁条件，解决方式。  

##  	**Java****基础**  

 	1、面向对象特性介绍、与C++区别  

> 封装继承多态
>
> Java 没有指针，C++有指针概念
>
> Java有GC，C++没有
>
> Java只能单继承，C++可以多继承
>
> Java字符串不可更改，C++ 字符串以'\0'结尾

 	2、多态实现原理  

> 接口  和 继承

 	3、抽象类和接口区别，以及各自的使用场景  

 	4、泛型以及泛型擦除。List<A>类型的list,可以加入无继承关系的B类型对象吗？如何加入？  

>Java泛型是伪泛型，在编译之后会泛型擦除，去掉所有泛型的信息。编译后 List<String> -> List 
>
>通过反射机制在运行时调用add方法，将对象加入。

 	5、Java异常体系  

> Throwable是整个异常体系的父类，有两个子类Error 和Exception，Error是致命错误，一般会终止线程。Exception 下分为运行时异常和检查性异常。对于运行时异常可以不捕获 如 Nullpointer Exception，对于checked 异常必须显示处理异常，不然编译不通过 如IOException。

 	6、反射原理以及使用场景  

 	7、ThreadLocal原理，如何使用？  

 	8、内存泄漏的场景  

>内存泄露最常见的场景是集合类的使用，即使集合内部元素不在使用，当集合本身没有释放，导致集合内部元素都不能释放，从而内存泄露
>
>另外还有数据库连接，网络IO没有正常关闭都会导致内存泄露
>
>还有一些比如不正确的使用单例模式，因为单例一般存活周期非常长，如果单例内部有其他对象的引用，其他对象就不能释放。

 	9、static关键字和final关键字使用情况，一个类不能被继承，除了final关键字之外，还有什么方法（从构造函数考虑）？ 

>如果类中只有private的构造方法，那么此类不可以被继承

 	10、序列化和反序列化。反序列化失败的场景。  

>序列化就是将对象转换为字节编码，反序列化就是将字节编码构建为对象。
>
>不希望序列化的成员加上transient 关键字
>
>一般需要序列化的对象都手动管理serialVersionUID，再对类进行了更改升级后需要手动修改serialVersionUID。（修改serialVersionUID 要谨慎，如果只是新增/删除了属性，不需要修改serialVersionUID，如果是修改了原有属性，需要修改）

 	11、ArrayList和LinkedList的区别和底层实现？如何实现线程安全？  

 	12、List遍历时如何删除元素？fail—fast是什么？fail—safe是什么？  

>通过迭代器遍历删除
>
>fail-fast 是再遍历集合时，如果发现元素已经被修改（被其他线程），立即抛出异常。
>
>fail-safe是在遍历集合前，先复制一份，在复制上访问元素。
>
>CopyOnWriteList 就是如此实现的，也可以是线程安全的List

 	13、详细介绍HashMap。角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N+JDK1.7与JDK1.8的区别。  

 	14、HashMap如何实现线程安全？ConcurrentHashMap的底层实现？JDK1.7与JDK1.8的区别  

 	15、正则表达式会写吗？  

 	16、设计模式了解吗？  

>六大原则：
>
>**一、单一职责原则(Single Responsibility Principle)**
>
>##### 二、开放封闭原则（Open Close Principle）
>
>##### 三、里氏替换原则（Liskov Substitution Principle）
>
>##### 四、依赖倒置原则（Dependence Inversion Principle）
>
>##### 五、 接口隔离原则（InterfaceSegregation Principles）
>
>##### 六、 迪米特原则（Law of Demeter）也称最少知识原则

 	17、linux指令知道哪些？  

>文件操作相关的 cd，ls，mkdir，rm，cp，mv，cat，gzip，unzip，tar 
>
>进程管理相关 ps，top，nice， free 
>
>磁盘管理 df
>
>IO相关的 iostat
>
>网络相关的 wget ping，netstat （查看端口占用之类的）

##  	**JVM****相关**  

 	1、JVM运行时内存划分？PC+虚拟机栈+本地方法栈+堆+方法区+JDK1.7与1.8区别  

>这三者每个线程一份 ———— 本地内存
>
>虚拟机栈：
>
>本地方法栈：
>
>程序计数器：
>
>堆和方法区所有线程共享 ———— 主内存
>
>堆：所有对象（类对象和实例对象）
>
>方法区（1.8之前也叫永久代，1.8之后叫元空间，移动给本地内存管理，不受jvm内存限制）：类的方法

>常量池：包含两大类常量 （1.7之前在方法区中，1.7之后移动到了堆内）
>
>- 字面量：如string 的文本字段，数字，声明为final的常量值
>- 符号引用：类的完全限定名，方法名称，字段名称和描述符

 	2、堆内存分配策略  

 	3、Full GC触发条件  

 	4、如何判断对象是否存活？回收对象的两次标记过程。  

 	5、垃圾回收算法以及垃圾回收器介绍，尤其是G1和CMS的优缺点  

>4种垃圾回收算法，标记-清除，标记-整理，复制算法，分代算法
>
>7种具体实现的垃圾回收器，
>
>新生代：Serial 收集器，ParNew 收集器，Parallel Scavenge收集器（注重吞吐量，自适应调节参数，不能和CMS一起工作，适合计算量的，不注重交互的服务器）
>
>老年代：Serial Old 收集器，Parallel Old 收集器（吞吐量优先），CMS收集器（注重最短响应时间，减小停顿，真正的并发回收，采用标记-清除算法
>
>优点：停顿时间短
>
>缺点：更耗费CPU资源，标记-清除算法产生内存碎片，无法处理浮动垃圾）
>
>G1收集器：可同时工作在新生代和老年代
>
>（并发和并行，注重停顿时间并可以预测停顿时间，空间整合，不产生内存碎片，直接管理整个堆-虽然保留了分代收集的概念，
>
>缺点是：Region大小不好控制，占用内存大）
>
>![img](https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg)
>
>

 	6、创建一个对象的步骤  

> 类加载+分配内存+初始化零值+设置对象头+执行init方法
>
> 分配内存的两种方式：1 指针碰撞--堆内存规整 2. 空闲链表--堆内存不规整
>
> 并发分配内存的问题：1. CAS+失败重试 2. TLAB，预先给每个线程分配一块内存，线程先在TLAB创建对象，当TLAB空间不足时才用CAS算法。
>
> init 方法（又叫实例构造器）包括：父类变量初始化 父类语句块 父类构造函数 子类变量初始化，子类语句块 子类构造函数

 	7、详细介绍类加载过程  

>加载+连接+初始化
>
>加载的主要过程是获取Class字节流，在方法区生成对应数据结构，并在堆上最终生成类对象（类对象有指向方法区的指针，方法区就包含这个类的函数）。
>
>连接又分为三步：
>
>- 验证：检查Class字节流是否符合规范
>- 准备：为类静态变量分配内存，初始化零值
>- 解析：将符号引用替换为直接引用（方法名符号改为指向方法区的引用）
>
>初始化：（执行cinit方法，类构造器）父类静态变量初始化，父类静态语句块，子类静态变量初始化，子类静态语句块
>
>何时初始化：第一次使用类的时候才初始化

 	8、双亲委派机制，使用这个机制的好处？破坏双亲委派机制的场景？如何破坏？  

>双亲委派机制就是类加载器加载类时，首先委派给父类加载器加载，如果父类加载器加载不了，再由自己加载。  
>
>好处是避免类重复加载，保证Java核心API不会被篡改
>
>系统默认实现三个加载器，优先级为BootStrap （启动加载器）， Extension（扩展加载器），Application（应用加载器）



> 避免双亲委派机制：自己定义类加载器，继承ClassLoader类，重写loadclass 方法。
>
> 场景：Tomcat就是自己实现了自己的类加载器，部分理由：加载同一个类库的不同版本，Tomcat要部署多个web应用程序，每个web应用程序应该是隔离的（使用相同类库但版本不同，存在相同限定名的类），因此Tomcat实现了web应用类加载器，该加载器指加载该web应用目录下的类，而不会交给父类去加载。

>注：这里的父类不是通过继承实现的，这里的父类更多是优先级的意思。

 	9、了解下tomcat的类加载机制  

 	10、JVM性能调优，常用命令，以及工具  

对象访问的两种方法

>1. 句柄， 引用存储的是句柄的位置，句柄存储真实对象的位置
>2. 直接地址
>
>差别：句柄的话 在对象移动时只需要修改句柄，不需要修改所以reference
>
>直接地址 查询速度块，句柄需要查询两次地址。

##  	**多线程并发**  

 	1、进程线程区别，线程安全和非线程安全区别  

 	2、线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别  

> start 是将子线程加入就绪队列，当子线程得到cpu时间片就开始执行。
>
> run 是子线程运行期间要执行的内容，如果直接调用，就是普通的方法调用，相当于在父线程调用方法。 
>
> yiled 是将线程切换至ready状态，让出时间片给其他线程使用
>
> 

 	3、wait,notify阻塞唤醒确切过程？在哪阻塞，在哪唤醒？为什么要出现在同步代码块中，为什么要处于while循环中？

>线程调用wait函数时，线程会释放目前占用的对象锁，状态变为waiting状态，线程会被放置到等待队列中，等待事件或中断的发生
>
>线程调用notify函数，从等待队列中将一个等待的线程唤醒，唤醒的线程会重写尝试获取对象锁。获取成功后会从wait方法之后开始执行。
>
>wait和notify都要拥有对象的锁才能调用，否则会抛出异常。
>
>wait等待某个条件的情况下，即使被notify唤醒也不能保证条件还继续满足，因为可能其他线程在唤醒的这段时间里已经将条件变得不满足了。所有wait某个条件的话，唤醒了之后需要重新检查一遍，放在while循环中。

 	4、线程中断，守护线程  

> interrupt() 给线程的中断标志置为1，线程执行费时操作时应手动检查中断标志，如果中断标志出现，则应进行相关处理。
>
> 系统实现的大量阻塞函数再被中断时都会抛出中断异常，在需要中断的场景可以借鉴使用。

 	5、Java乐观锁机制，CAS思想？缺点？是否原子性？如何保证？  

 	6、synchronized使用方法？底层实现？  

>减小加锁的范围，
>
>底层实现通过monitor监视器方法，在进入同步代码前执行monitorenter 方法，获取对象锁，在退出同步代码是，调用monitorexit，释放对象锁。

 	7、ReenTrantLock使用方法？底层实现？和synchronized区别？  

>两者都是可重入锁。ReenTrantLock 中文名是重入锁,synchronized 依赖于底层JVM,是java语法层面实现。而ReenTrantLock是依赖于API，是java代码层面实现的。
>
>ReenTrantLock 比synchronized多了一些高级功能，等待可中断，可以实现公平锁，可以选择性通知。不过需要手动释放锁，不手动释放的话可能出现死锁。synchronized不需要手动释放。
>
>synchronized经过优化后性能已不输ReenTrantLock 。

 	8、公平锁和非公平锁区别？为什么公平锁效率低？  

>1. 公平锁需要维护一个队列，有额外的开销
>2. 非公平锁后来的线程有几率不需要等待直接获取锁，减少了挂起的概率。公平锁只要队列有其他线程，线程就必须等待。

 	9、锁优化。自旋锁、自适应自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、重量级锁解释  

>synchronized优化：锁粗化，锁细化，锁消除，偏向锁，轻量级锁，重量级锁。

 	10、Java内存模型  

 	11、volatile作用？底层实现？禁止重排序的场景？单例模式中volatile的作用？  

>底层实现是:内存屏障和lock 指令,lock指令保证了在对volatile 变量写操作后,会将缓存本地内存刷新回主内存.内存屏障保证了volatile的前后语句禁止重排序.
>
>单例模式中volatile作用为禁止重排序,从而防止其他线程误读null.

 	12、AQS思想，以及基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍  

 	13、线程池构造函数7大参数，线程处理任务过程，线程拒绝策略  

 	14、Execuors类实现的几种线程池类型，阿里为啥不让用？  

>CachedExcutor
>
>newFixedThreadPool
>
>SingleThreadExecutor

 	15、线程池大小如何设置？  

 	16、手写简单的线程池，体现线程复用  

 	17、手写消费者生产者模式  

 	18、手写阻塞队列  

 	19、手写多线程交替打印ABC  

##  	**MySQL**  

 	1、事务4大特性，一致性具体指什么？这4个特性mysql如何保证实现的？  

>ACID,
>
>原子性：通过事务回滚实现，undo logo
>
>一致性：通过实现其他几个特性
>
>隔离性：四大隔离级别，通过共享锁，独占锁，间隙锁，MVCC等实现
>
>持久性：通过redo log，保存到磁盘实现

 	2、事务隔离级别，4个隔离级别分别有什么并发问题？  



 	3、Mysql默认隔离级别？如何保证并发安全？  

 	4、RR和RC如何实现的？RR使用场景？对比volatile可见性，为什么RR的事务要设计成不能读另一个事务已经提交的数据？ 

>RC实现是修改的时候加锁，读取的采用MVCC，并行读。每次读都是已最新的数据生成数据视图。
>
>RR实现修改同样加锁，读取MVCC是事务第一次执行Select语句会生成事务的数据视图，数据视图不会改变，保证可重复读。
>
>一般大多数业务RC就可以满足需求。不过有些隔离性要求高的业务需要RR隔离级别（事务执行过程不能受到别人的影响），比如金融行业对账，计算上月余额-当月消费是否等于现在余额，如果余额在一直在变动，那就一直不一致了。

 	5、隔离级别的单位是数据表还是数据行？如串行化级别，两个事务访问不同的数据行，能并发？  

>行，可以.

 	6、存储引擎Innodb和Myisam的区别以及使用场景  

> Innodb 支持事务，支持回滚，支持日志记录，支持崩溃恢复，支持行级锁，使用聚集索引，支持MVCC，支持外键。——适合 绝大数的场景
>
> Myisam 上面不支持，默认表级锁，非聚焦索引，相对读性能较好，提供全文索引，压缩等特性。——写少，读密集应用

 	7、 介绍Inodb锁机制，行锁，表锁，意向锁  

 	8、介绍MVCC.  

 	9、哈希索引是如何实现的？  

 	10、B树索引为什么使用B+树，相对于B树有什么优点？为什么不能红黑树？要提到磁盘预读  

>红黑树太高，查询次数多。根据程序局部性原理，B+树可以有效的做到磁盘预读，而红黑树相邻内容相聚较远。

 	11、聚簇索引和非聚簇索引区别  

>聚焦索引叶子节点是数据节点，非聚焦索引叶子节点存储的是主键ID，需要回表查询主键索引才能取到数据。

 	12、回表查询和覆盖索引  

>覆盖索引是索引中包含原始数据，如果索引中数据满足查询要求，就直接返回数据，不需要回表查询。
>
>回表查询是非主键索引只是查询到数据的主键ID，通过主键查询主键索引拿到数据。

 	13、如何创建索引？  

>创建表的时候指定
>
>在建表后使用Create Index命令建立

 	14、如何使用索引避免全表扫描？  

>最左匹配原则,索引列不要参与计算,索引选择高区分度的字段进行建立。

 	15、Explain语句各字段的意义  

 	16、最左前缀！！联合索引B+树是如何建立的？是如何查询的？当where子句中出现>时，联合索引命中是如何的? 如 where a > 10 and b = “111”时，联合索引如何创建？mysql优化器会针对得做出优化吗？  

 	17、MySQL中一条SQL语句的执行过程  

>首先是查缓存，缓存不匹配 给SQL解释器，解释SQL语句，之后送给SQL优化器，优化查询生成执行计划，最后送给SQL执行器执行获取数据。

 	18、数据库几大范式  

 	19、数据库基本查询关键字使用，如left join on,where,beteen and,group by,having,limit,聚合函数等。  

 	20、left join,right join,inner join,outer join的含义及区别  

 	21、mysql主从复制过程，binlog记录格式，复制的异步半同步同步模式区别  

 	22、主从复制或读写分离等数据不一致性问题以及如何解决  

 	23、银行的话，可以会考mysql数据类型，如余额要用decimal  

##  	**Redis****问题：**  

 	1、为什么使用Redis  

 	2、分布式缓存和本地缓存有啥区别？让你自己设计本地缓存怎么设计？如何解决缓存过期问题？如何解决内存溢出问题？ 

 	3、redis和mem***d的区别  

 	4、redis常用数据结构和使用场景  

 	5、Zset底层实现？跳表搜索插入删除过程？  

 	6、redis过期淘汰策略  

 	7、redis持久化机制？都有什么优缺点？持久化的时候还能接受请求吗？  

 	8、redis事务  

 	9、缓存雪崩和缓存穿透，以及解决方法  

 	10、如何保证缓存和数据库的数据一致性？  

 	11、redis是单线程还是多线程？为什么那么快？  

 	12、五种IO模型的区别  

 	13、select、poll、epoll的区别？  

 	14、redis热key问题？如何发现以及如何解决？  

 	15、redis数据分布方式？有什么优点？一致性hash呢？  

 	16、redis主从复制，主从切换，集群  

##  	**Spring**  

 	1、Spring IOC  

 	2、Spring AOP，动态代理 

 	3、Bean生命周期  

 	4、Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?  

 	5、Spring事务隔离级别和事务传播属性  

 	6、Spring以及Spring MVC常见注解  

 	7、@autowired和@resource的区别，当UserDao存在不止一个bean或没有存在时，会怎样?怎么解决？  

 	8、mybatis如何防止sql注入？$#的区别是什么？传入表明用哪个？  

 	9、Spring MVC工作原理  

 	10、SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.  

 	11、Mybatis和Hibernate的区别  

 	12、spring中的注解原理？例如事务注解，spring如何根据注解实现事务功能的  

 	13、Spring中用到了哪些设计模式？单例、***、工厂、适配、观察者之类的说一说就行  

##  **大数据和空间限制与系统设计**  

10 亿 B = 1 GB = 2^30

 	1、100亿黑名单URL，每个64B,判断一个URL是否在黑名单中  

>将100亿黑名单通过hash分成1000个文件，相同url会被hash到同一个文件。根据target url的hash查找对应文件即可
>
>为了实时效率可以考虑布隆过滤器

 	2、2GB内存在20亿整数中找到出现次数最多的数  

>1. hash方法，将20亿整数hash分成10个文件，然后逐个统计最多（开一个hash表，key是整数4B，value是整数4B）8B一条，一个文件1.6GB左右，再加起来
>2. 40亿整数计数的话，计数值初始化为-2^31
>3. 80亿整数的话，计数的时候判断是否超过2^31，超过就说明是最多的数了。

 	3、40亿个非负整数中找到没有出现的数  

>Bitmap 位图思考：建立Bitmap位图，一位代表一个整数，2^32 位代表整个整数范围。
>
>空间上大概只需要500MB

 	4、40亿个非负整数中找到一个没有出现的数，内存限制10MB  

>分段划分，非负整数范围0~2^32，10MB内存，至少划分50份（保险期间划分64份），每份建立bitmap，判断未出现的数。

 	5、找到100亿个URL中重复的URL

> 将URLhash分配到20个文件中，平均一个文件5亿个URL（一个url的hash，2GB内存建立HashSet判断是否重复。 

 	6、海量搜索词汇，找到最热TOP100词汇的方法  

>Hash 分成多份，每份统计前100，统计之后合并

 	7、40亿个无符号整数，1GB内存，找到所有出现两次的数 

> Bitmap
>
> 内存小就按照数字大小分段划分，每段建立Bitmap

 	8、10MB内存，找到40亿整数的中位数  

>按数字大小分段划分，每次统计一段范围的数的个数. 10MB内存，最多存250w个整数，40亿/250w=1600段，分为1600段，将40亿整数存到这些段的文件里面。根据统计第20亿个数即是中位数，找到中位数的文件，从里面找到中位数（快排）。

 	9、设计短域名系统，将长URL转化成短的URL.(知乎老哥给出了答案，博客有人根据他的总结了一下，很好) 

 	10、让你系统的设计一个高并发的架构，你会从哪几个方面考虑？  

 	11、一个千万级的APP，你要搞定关注和粉丝列表，你用什么来做。要求最后一个关注的在最前面。新增和取关都要比较快的反馈你怎么做？如果一个人关注了之后，服务器宕机了怎么办？  

 	12、OOD design：计费停车场  

 	13、假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写  

 	14、显示网站的用户在线数的解决思路  

## 智力题

 	**项目**  

 	如果个人没有好的项目，就用高并发秒杀。B站搜高并发秒杀，有慕课网视频，讲的很好。Github搜秒杀，有代码，跑一遍。有时间自己写一遍，没时间就看懂就好。然后准备问题，不要求每个功能都实现的特别好，但一定要多考虑系统可能出现的问题，因为很多人都是这个项目，你考虑的多，自然就显得稍微那么好了点。  

 	1、如何解决超卖？mysql锁+redis预减库存+redis缓存卖完标记  

 	2、如何解决重复下单？mysql唯一索引+分布式锁  

 	3、如何防刷？IP限流+验证码  

 	4、热key问题如何解决？redis集群+本地缓存+限流+key加随机值分布在多个实例中  

 	5、消息队列的作用？如何保证消息的不丢失？异步削峰；发送方开启confirm+消息队列持久化+消费方关闭自动ACK,确保消费成功之后自动调用API进行确认。  

 	6、缓存和数据库数据一致性如何保证？秒杀项目不用保证，其他项目就用延时双删或者先更新数据再是缓存失效，为防缓存失效这一信息丢失，可用消息队***保。  

 	7、压测没有？用什么压测？什么情况？  

 	8、系统瓶颈在哪？如何查找，如何再优化？  

 	**面经之手撕代码**  

 	但凡好点的互联网公司，必然要求手撕代码。如果代码都不让你写，要么这公司根本不行，要么这公司压根就不想要你，例如京东(三面加一块面我不到一个小时，果然没给做兄弟的机会)。就连华为都开始手撕代码了，想想吧——其实现场面试的手撕代码远比视频面试的在线答题好得多，因为在线可能需要调试运行，一点错都不能出，而现场手撕，只要思路没问题，时间复杂度和空间复杂度没问题，大致写出来就行，即使错了一点点，面试官可能也发现不了。  

 	对很多大厂而言，手撕代码是万万不能出错的，大多题目都是LeetCode里面的，题一抛出，必须马上给出思路，然后直接写出来。如果需要面试官提示才能勉强答出，就已经落入下乘了(猿辅导可能就挂在二面代码题写得太慢了)。所以多刷题，这一环节的结果好坏其实就是取决于面试官的题目自己是否曾经刷到过，是否能够顺利答出。刷题的基本要求是完成剑指offer那70道题左右，加上自刷LeetCode130道中等难度的。然后将所面试公司的他人面经提到的代码题整理一下，查漏补缺，就没问题了。  

 	代码题一般分为几类：排序、二分查找、数据结构、数组、字符串、链表、树、回溯、动态规划、贪心、数学。首先三大排序算法快排、归并、堆排序一定特别熟练，时间复杂度一定要特别熟悉。如果这三个都没有掌握，面试就先放放吧。快排如何写，什么思想？用快排思想求无序数组中第K小的值如何写？时间复杂度多少？归并如何写？什么思想？用归并思想给链表排序如何写？用归并思想求数组中逆序对数如何写？M个长度为N的数组如何排序？时间复杂度多少？M个长度为N的链表如何排序？堆排序如何写，什么思想？时间复杂度怎么算的？符合堆的结构，插入和删除函数如何实现？把这几个问题弄会，三大排序问题基本就没问题了。二分查找，有序数组直接考虑二分查找，如旋转有序数组的最小值、旋转有序数组查找目标值、有序数组目标值的最左和最右位置、二分查找寻找峰值，二分查找问题，要考虑while(left <= right)是否可以等于，right = mid还是right = mid +1,返回值是left还是right，反正多考虑考虑边界问题。数据结构，也就是栈、队列、双向队列之类的，问题不大。数组和字符串，简单的时候很简单，难的时候很伤脑子，这类题一出基本都是要求你使用最低时间复杂度和空间复杂度计算的，多背背题目，多看看面经总结总结吧。链表，掌握好链表逆序,快慢指针，保留pre节点和当前cur删除符合条件的节点，把这些掌握了，基本能解决八成的链表问题。树，掌握层序遍历+size+flag、非递归中序遍历、非递归前序遍历、二叉搜索树特点、完全二叉树特点及善用递归解决树深度，树是否平衡，树节点最大距离，树节点最长带权路径，最近公共父节点等问题，基本解决八成树问题。回溯，两大类排列和组合，总结排列组合类型的各自特点，以及考虑去重！动态规划，多做多总结，不过一般出现在笔试中，面试很少有特别难的动态规划，即使出也很并不难。贪心，少见，做几道就好。数学，挺难的，没做过类似的真未必想起来，主要就是位运算，其中&和异或最常见，还有就是0-n顺排，求第K位的数字是多少，以及0-N,数字7或者1出现的次数，利用random5实现random7等。  

 	**剑指offer的题目：**  

 	No3.数组中重复的数字。n个数，范围0到n-1,找到任意一个重复的,时间复杂度O(1);  

>1. 使用原有数组空间复杂度O（1），全-n
>2. 将问题转为环状链表，双指针找环入口点

 	No4,二维数组查找，从左到右递增，从上到下递增。   

>右上角排除法

 	No5,字符串空格替换，如果有空格，就将他替换成%20 

 	No6,从尾到头打印链表,递归和非递归方法  

 	No7 重建二叉树,前序遍历和中序遍历重构二叉树  

>根据规则来

 	No8 二叉树的下一个节点。中序遍历的二叉树下一个节点，这个树的节点，有指向父指针;  

>中序遍历右子树，右子树第一个节点
>
>右子树为空，下一节点是父节点，

 	No9,两个栈实现队列  

 	No10 斐波那契数列;  

 	No 10-1,青蛙可以挑一阶，也可以2阶，跳到n阶，几种做法  

>斐波那契额数列

 	No10-2,变态跳，可以跳1-n阶，随便跳。求n阶几种方法;  

 	No11,旋转数组最小的数字：非减排序的数组，可能存在重复  

>二分查找，找到旋转点，旋转点就是最小的

 	No12,矩阵中的路径。矩阵有字符，可以从任意开始，上下左右任意走，但不能走走过的格子，求是否存在一条包含给定字符串的路径。 

>深度优先遍历

 	No13,机器人的运动范围，从(0,0)开始，上下左右移动，但不能进入行坐标和列坐标数位之和大于k的格子，给定k,能打几个格子。 

>广度优先遍历

 	No14,剪绳子，长为n，剪m段（m,n都是整数，且m>1），所有的长度的乘积最大为多少。  

>3最好

 	No15,二进制中1的个数;  

 	No16, 数值的整数次方  

>快速冥

 	No17, 打印从1到最大的n位数 

> 相当于n位数的全排列

 	No18-1,删除节点。给定一链表头结点和指定节点，O(1)时间内，删除指定节点

 	No18-2.删除重复的节点。存在的重复节点，全都删了。  

 	No19,实现函数来匹配包含‘.’和‘*’的正则表达式.  

> 背

 	No20实现一个函数来判断字符串是否表示数值。

>  

 	No20-2将字符串转换成整数；不合法返回0；  



 	No21,调整数组顺序使得奇数位于偶数之前。  

>patition操作

 	No22,返回链表的倒数第k个节点。

> 双指针 

 	No23,链表中环的入口节点;  

>双指针

 	No24,反转链表,并返回反转之后的头结点。 

 	No25,合并两个有序的链表，重建一个新的，包含所有的两个链表。--->单调不减  

 	No26,输入A和B两个树，判断B是A的子树。空树不是子树  

 	No27,二叉树的镜像。输入一个二叉树，将他变成他的镜像  

>左右交换

 	No28,输入一个二叉树，判断二叉树是不是对称的。  

>递归思想，拆分为两棵树，自己和自己

 	No29,顺时针打印矩阵。  

 	No30,包含min函数的栈  

>1. 单调队列
>2. 含有min的链表

 	No31,栈的压入弹出序列,第一个表示压入序列，判断第二个是不 是弹出序列。  

>模拟

 	No32,从上到下打印二叉树  

>层次遍历，一个queue，一个循环，一个反转走天下

 	No33,输入一个整数数组，判断是不是二叉搜索树的后序遍历序列  

>中序遍历是递增的
>
>后序遍历，单调栈

 	No34,二叉树中和为某一值得路径  

>递归子树

 	No35复杂链表的复制;链表不仅有val,next,还有一个指向任意节点random  

>O(N) 空间复杂度 正常复制,将新旧节点的对应关系存到map里,再重来一遍修改random
>
>O(1) 时间复杂度 每次复制新节点在老节点后面,复制完后拆分开

 	No36二叉搜索树和双向链表;二叉搜索树转换成一个排序的双向链表，不能创建新的节点,只能调整指针顺序。 

>中序遍历

 	No37实现函数序列化二叉树和反序列二叉树  

>序列化就是层次遍历,注意的可以加入null节点
>
>反序列化就是重新建立二叉树,一样是层次遍历

 	No38输入一个字符串，给出所有的排列;  

>全排列问题，一个字符不可使用两次，比全排列多了个同一个位置不使用相同的字符就行。

 	No39,数组中出现超过一半的数字,如果不存在，返回0；  

>摩登投票

 	No40，最小的k个数

> 1.  最大堆，求出最小的k个数
> 2. partion 分治法

 	No41，数据流中的中位数，奇数个，中间那个。偶数个，中间俩的平均.  

>两个堆，一个大顶堆，一个小顶堆

 	No42,连续子数组的最大和，数组中有正数有负数，求所有连续子数组的最大和。  

>状态转移方程。前面连续的>0加上，<0自立

 	No43,1-n所有数中，求所有十进制位出现1个总数  

 	No44，从0-n,所有的从前到后排到一块，实现一个函数，求第k位的数字是几？  

 	No45,给定一个数组，求组合到一块的最小数字  

>数组排序

 	No46,0-25翻译成a-z,给一个数字，求有几种翻译方法  

>状态转移

 	No47,礼物的最大价值，矩阵，每一步都有一个值，从左上到右下，只能向右或向下移动，求最大和 

>状态转移

 	No48，最长不含重复字符的子字符串，  

>1. 一个Map，存字符出现的index，废弃的index存起来也无所谓。
>
>2. 滑动窗口，数组做hash set

 	No49,只含2,3,5因子的数是丑数，1也是，求第n个丑数  

>动态规划

 	No50，第一个只出现一次的字符,返回的是位置

> 数组hash set 

 	No51，数组中的逆序对,归并排序！！！  

 	No52,两个链表的第一个公共节点。  

 	No53,在排序数组中查找数组，一个数字出现了多少次  

 	No54,二叉搜索树中，第K小节点  

 	No55-1，二叉树深度  

 	No55-2,是不是平衡二叉树  

 	No56-1,一个数组，一个出现一次，其他出现两次，求一次的。  

>一个一次 全部异或即是
>
>两个一次，全部异或，找到最低位的1，根据最低位的1将所有数分成两边异或

 	No56-2,数组，一个出现一次，其他出现三次。求一次  

 	No57-1，递增排序的数组，和target.找出一对和为target的数字  

> 双指针

 	No57-2,正数s,给出连续正数序列，其和未s.所有的序列。序列最少有俩。  

>滑动窗口

 	No58-1,翻转单词顺序  

 	No58-2,左旋转字符串  

 	No59-1给出数组和窗口大小，求滑动窗口的最大值。 

>优先级队列—— 滑动窗口求连续数组最大值

 	No59-2,实现带有max函数的队列，出入队和max都是O(1)  

>优先级队列

 	No60,n个色子，点数和为s，s所有可能出现的值得概率  

>动态规划

 	No61,扑克牌抽5个数，是不是顺子。大小王可以为任何;  

 	No62,0到n-1,围一圈，从0开始，删除第m个数字。求最后的数字；  

>倒序思考，约瑟夫环问题

 	No63,数组，值为股票当时的价格，求最大利润  

 	No65,不用加减乘除做加法  

 	No66，构建乘积数组。  

 	**LeetCode****的一些题目：**  

 	1. Two Sum:给定数组和target,返回两个元素之和为target的元素index;  

 	2. Add Two Numbers：他是一个反转的链表，求真正链表代表数字的和的链表的翻转；  

 	3. Longest Substring Without Repeating Characters：字符串最长的不重复子序列长度：  

 	5. Longest Palindromic Substring：字符串最长的回文序列。  

 	6. ZigZag Conversion：一个字符串，一个行数。然后字符竖折竖折来排序。然后一层一层的组合字符。  

 	7. Reverse Integer：将整数值反转，如120变21，-21变-12，考虑值超过int溢出。  

 	8. String to Integer (atoi)：将字符串转化为整数  

 	9. Palindrome Number，一个数，正反来是否一样。负数不一样。  

 	12. Integer to Roman，给定一个数，转化成罗马数字。  

 	14. Longest Common Prefix；N个字符串，求这N个字符串最长公共前缀  

 	15. 3Sum,数组中，找3个和为0为三个数，每个数不能用两次。要考虑重复的问题。  

 	16. 3Sum Closest:一个数组，找出3个和最进阶target的。  

 	17. Letter Combinations of a Phone Number，给定数字，求九宫格拼音下的所有组合。回溯  

 	18. 4Sum.数组中4个数之和为0，考虑重复的数.  

 	19,删除倒数第k个节点  

 	20、括号序列是否匹配：  

 	21、合并两个有序链表，递归和非递归方式。  

 	22、n对小括号的全正确排序：回溯  

 	24. 成对的翻转链表  

 	26、有序数组，删除多余的重复数组，in-place删除，然后返回长度。  

 	27、数组，删除指定的数字；  

 	28、实现indexOf(String s1,String s2);  

 	33、左移一部分的有序数组中，查询target。二分查找的经典题目  

 	34、有序数组中，查询一个target第一次和最后一次出现的位置；二分查找的经典题目  

 	35、将一个数插入到有序数组中，求位置  

 	39：非重复数组，找出和为target的数组，一个不能用两次；回溯。  

 	40，带有重复的数组，找出和未target的数组组合，一个不能用两次；回溯+组合  

 	43，两字符串的数字，相乘，得到结果，输出字符串。  

 	46,不重复数组的，所有全排列；回溯+排列  

 	47，带有重复的数组，全排列；回溯+排列+去重  

 	48：n x n矩阵，顺时针转动90度。  

 	49，一群字符串，有些字符串字母组成一样，有的不一样，将一样的放一块；  

 	50：计算power(x,n); x在正负100，n在正负 2^31;  

 	54:一圈圈顺时针打印数组。  

 	58：最后一个单词的长度。  

 	59：给一个N,将1-N^2,整成上面外圈顺时针到里圈的矩阵。  

 	60：1-N这n个数字的全排列，求第K小的；  

 	61、翻转链表，链表右移K为，可以循环多移；  

 	62、矩阵移动，mxn矩阵从左上角移动到右下角，只能横移和竖移，共有多少方法；  

 	63、矩阵移动，从左上移动到右下：横竖移动，矩阵值为1的不能走；求多少种移动方式。  

 	64、矩阵，从左上到右下，最短的路径和多少。  

 	66、数组表示的数+1，然后返回之后的。  

 	67、两个二进制字符串相加，得到的二进制字符串。  

 	69. Sqrt(x)  实现int sqrt(int x)；  

 	73、MxN的数组，如果有一个为0，那么就让起其所有列和行都为0，求最后的数组；  

 	74、mxn的矩阵，层序遍历就是有序的数组。在矩阵中搜索target;  

 	75：一个只有2、1、0的数组，将0分到左边，2移动右边。  

 	77:1-N，挑选K个进行排列；  

 	78：求数组的所有子集合。  

 	80：删除有序数组中过于多余的数字，最多每个出现两次。  

 	81：翻转部分的有序数组，可能存在重复，搜索target;  

 	82：删除有序链表，将重复的全都删了；  

 	83：删除有序链表多余的节点，重复的保留一个。  

 	86：链表，给定target，将比target小的节点移动到左边。大的和等于的移动到后面。其他相对位置不变。 

 	  

 	88：将两个有序数组合到第一个数组中；  

 	90：可能有重复元素的数组，求所有的组合。  

 	91：将数字解码成A-Z;1-26;给出数字字符串，有几种解码方式：  

 	92：逆转链表的m-n这部分；  

 	93：给定一数字字符串，输出可能的IP地址列表。  

 	94,二叉树中序遍历：  

 	96：n个节点，共有多少种二叉搜索树。  

 	98:判断一个树，是否是二叉搜索树。  

 	100：判断两个树是否一致。  

 	101：判断一个树是否对称。  

 	102：二叉树层序遍历。  

 	103,之字形打印二叉树  

 	104:二叉树的深度:  

 	105：前序和中序构成二叉树。  

 	106：中序和后序构成二叉树  

 	107：层序遍历：从底层到上层；  

 	108: 将有序数组转化成二叉搜索树  

 	109：将有序链表转化成二叉搜索树：  

 	110:是否平衡二叉树：  

 	111：叶节点到根节点的最短路径。  

 	112：二叉树是否存在从根节点到叶节点的路径和为target:  

 	113:找出所有路径和为target的序列  

 	114：将二叉树往一边偏；  

 	116：满二叉树，将为每个节点加上next，就是每层的右边那个。  

 	117：二叉树，将为每个节点加上next，就是每层的右边那个。  

 	125：字符串是否回文，只考虑数字和字母，大小写不论。  

 	129：二叉树，从头结点到尾节点：拼接成数字，然后所有的加一块。  

 	136,一个数组，一个出现一次，其他的出现两次，求一次的那个  

 	137：数组，有人出现三次，有人出现一次，求一次的。  

 	138：带有random指针的复杂链表的复制：  

 	141. 链表是否有环：  

 	142：链表环入口节点  

 	143：重排链表：1-2-3-4-5；先第一，再最后一个，先第二个，再倒二，就这样。  

 	144：前序遍历二叉树：  

 	146. LRU Cache 

 	147：对链表进行插入排序，  

 	148：NlongN的时间排序链表。  

 	150、逆波兰  

 	151、单词逆序：  

 	155、带有最小值函数的栈  

 	160：两个链表的相交点  

 	165：比较版本号大小。如10.2.2大于3.1.2；  

 	167：有序数组，找出两数之和为target的索引。  

 	168：数字转化为26进制的A-Z；  

 	169. Majority Element，超过一半的数字  

 	171：26进制A-Z转化为十进制数字  

 	172：Given an integer n, return the number of trailing zeroes in n!.  

 	179：整数数组，求组合到一块的最大值。  

 	189：数组左移K位  

 	199：二叉树，从右边看到的节点数组。也就是每层最右边那个。  

 	200：dfs求岛屿的个数。1表示陆地，0表示岛屿。  

 	201：N-M数组的连续数，逐个&；求最后的结果。  

 	209 : 最短的连续子序列之和大于等于target;  

 	215：无序数组中找出最K大的数字：  

 	216：1-9的数，选出n个，之和为k。求所有N的组合，一个数不能用两次  

 	220：一个数组，是否存在不同的数i和j,使得nums[i]-nums[j]的绝对值最大是t,而i-j的绝对值最大是k;  

 	221：矩阵，有0有1；找出最大的正方形，其里面数值都1；  

 	222：给定一完全二叉树，求节点总个数。  

 	223：以(A,B)和（C,D）为对角顶点，构建矩形，以EF，GH构建，求纵的矩形面积。  

 	227：非负整数，有+-*/和空格数字的字符串组成的表达式，求表达式的值；  

 	228：给出排序好的数组，没有重复，将连续的整成0->2的形式，求所有的连续范围段。  

 	229，数组中超过n/3的次数的数。  

 	230:BST二叉搜索树中，第K小的节点，递归和非递归方式  

 	236：二叉树中，两个节点最近的公共祖先节点。  

 	238：构建乘积数组  

 	240：在矩阵中遍历，每行都增加，每列都增加。  

 	241：数字和操作符，+-*,请随便加括号改变计算顺序，然后得出所有可能的结果。  

 	260：数组，只有两个出线一次，其他的出现两次，求出现一次的那俩  

 	264：第K个丑数，因子只有2,3,5的数；  

 	274：if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each. 

 	275：同上，也是求H。但这个数组是有序的；  

 	287：N+1数，都是1-n之间，求重复的那个数。  

 	300：最长递增序列，可以不连续。但是前面的index比后面的小  

 	306：数字字符串，我们将字符串分割最少三个数字，然后Fn = Fn-1+Fn-2;  

 	313：求第N个超级丑数，并且给出数组因子，只有只包括该数组因子的数才是超级丑数  

 	318: 字符串数组，求两个没有公共字母的字符串长度乘积的最大值；  

 	319：开关转换，刚开始有N的灯，最初都是灭的，第一轮，每一个都按一个。第二轮每二个按一个开关。第N轮之后，亮着的灯的个数。  

 	322：给一堆零钱，可以重复使用，然后给整钱。将整钱换成零钱，求最小的零钱数，如果不能换，返回-1；  

 	324：无序数组重排序：nums[0] < nums[1] > nums[2] < nums[3]....   

 	328：链表重排序，将奇数位index,而不是奇数值的放到前面。偶数index的放后面：  

 	331：将一个二叉树，他的空子节点记成#，给定一个字符串，问这个是不是前序遍历；  

 	332 : 航班信息[from,to],一些列的这种数组信息，这人从JFK出发，求他的真正路线一次经过的城市；  

 	334：数字数组，是否存在三个子序列，可以不连续，是递增的；  

 	338：给定一num.求0-num这些数每个的二进制中1的个数。  

 	347，TopK出现频率最高的数字，一个数组，每个数字可能出现多次，求最K多出现的那k个  

 	343：给定一个整数，将他分成最小二段，和为这个整数，求这些段乘积的最大值。  

 	357:n位数的数，求没有重复数字的总个数。11,121这种就不行。  

 	**面经中遇到的题：**  

 	1、数组的逆序数   

 	2、LRU //hashMap加双向链表，双向链表有头尾节点，   

 	3、最长回文序列 leetocde 5  

 	4、矩阵中的最长递增路径，可以上下左右一起都走； leetcode329   

 	5、判断一个二叉树是另一个二叉树的子树   

 	6、归并排序的时间复杂度 // NlongN  

 	7、求给出01矩阵中的最大正方形面积（全为1） lc221  

 	8、求二叉树中距离最远的节点 leetcode543   

 	9、判断字符串是否为合法IPV4地址 lc468  

 	10、数组值为1-n，各出现一次，先加入x（x也是1-n的范围），找出x  

 	11、给定n，计算15n，不用+*/   

 	12、给定字符数组chars，将其右移n位  

 	13、100层楼，只有两个鸡蛋，找出鸡蛋会在哪一层楼被摔碎  

 	14、reverse linked list in a group of k   

 	15、如何空间O(0)实现两个数的互换  

 	16、IP地址的Regex   

 	17、the longest path in a binary tree  lc124  

 	18、the largest consecutive sum in an array   

 	19、LeetCode 41 Find mis sing positive   

 	20、给一个小于一亿的中文数字字符串,转化成数字格式  

 	21、一个数组,把所有的0都移动到末尾,还要保持顺序不乱 维持临界点j,如果当前遍历不是0，就和j互换  

 	22、罗马数字转整数 leetcode13   

 	23、二叉树的序列化和反序列化  

 	24、输入一个数组，输出数组中满足条件的数字，条件为：数组中当前元素的值大于等于它前面所有的元素，小于等于它后面所有的元素。  

 	25、给出一个数字，对数字的两位进行交换，只能交换一次，输出可能结果中的最小数字  

 	26、输入一个字符串，字符串中字符全部为数字，在字符串中插入 '.' 使得结果为合法的ip地址，输出全部可能的结果  

 	27、基数排序  

 	28、链表是否为回文结构。不能用栈  

 	29、最大不重复子串  

 	30、复杂链表复制  

 	31、长度为n的数组，元素大小是0~n-1,判断数组元素是否有重复的  

 	32、list1/list2交替打印元素  

 	33、36进制加法  

 	34、合并区间  

 	35、快排  

 	36、生产者-消费者 模型  

 	37、排序一个字符串时间要求O(n)  

 	38、给一个有重复数字的数组，求集合{(a,b,c) | a+b+c=0}  

 	39、两个栈实现队列  

 	40、二叉树转化为双端链表  

 	41、手写线程池  

 	42、之字形打印二叉树  

 	43、给定一个数组，调整该数组，使其满足堆的性质  

 	44、给定n个单词，如果单词组成一致但是元素顺序不一致，该对单词为同位词，例如：abc,bca为同位词．求所有同位词的集合输出  

 	45、链表，两个链表的公共点  

 	46、二叉树的后续遍历非递归形式  

 	47、买卖股票的最佳时机，只能一次买入和一次卖出  

 	48、可以进行多次交易的结果，求赚取的最大利润  

 	49、(A,B)(A,C)(B,D)(D,A)判断是否有循环引用，提示用拓扑排序  

 	50、数组找是否存在和为M的两个数  

 	51、KMP  

 	52、实现一个阻塞队列（生产者消费者模型）  

 	53、找出10000个数据中第 k 大的数  

 	54、输入一个字符串，包含数字、加减乘除和括号，输出结果，编程  

 	55、给定一个数x，要求使用k个数字求和可以得到x，数字从1-9中选择，不能重复。  

 	56、输入一个正整数 N，返回 N 个 '(' 和 N 个 ')' 的所有可能情况  

 	57、76.minimum-window-substring、30.substring-with-concatenation-of-all-words、42.trapping-rain-water，  

 	58、求树的最左下节点  

 	59、无序数组中第k大的数（quick select）  

 	60、求旋转数组找最小值（二分）  

 	61、判断二叉树是否镜像（递归）  

 	62、给定一个矩阵，从左上角开始只能往下或者右走，求到达右下角的最小权值路径  

 	63、字符串转Int，如果越界就返回0  

 	64、lc400  

 	65、单向链表实现加法  

 	66、打家劫舍  

 	67、收到礼物最大值  

 	68、五张牌，其中大小鬼为癞子，牌面为 0，判断这五张牌是否能组成顺子  

 	69、给定一个字符串打印所有的子串，要求不重复  

 	70、自然数1-n,排一块组成的字符串，求第k位是什么。  

 	71.如果a[0]<a[1],a[n-2]>a[n-1]，那么请找出任意一个点使得a[i-1]<a[i]>a[i+1] 要求logN  

 	72、a[-1]和a[n+1]设为负无穷大，二分查找找到数组中的一个峰值。  

 	73、如果有一组数字，按照“拿出第一个数在桌上并然后将下一个数放到队尾”一直操作直到数字全部放在桌子上，给你最后在桌子上的数字，请返回最开始数字的顺序。 

 	  

 	74、有序数组找到第一个小于0的数和第一个大于0的数  

 	75、合并两个排序数组并去重  

 	76、两个排序数组找中位数  

 	77、两个超大整数的字符串做减法运算。  

 	78、1~10000中7出现的次数，如17算1个，77算2个。  

 	79、给一个字符串数组，统计每一个字符串出现的次数，要求不能用set,map.时间复杂度O(n).  

 	80、手撕最大堆，实现对应的push和pop操作  

 	81、找出一个字符串中所有的回文子串  

 	82、重复次数最多的最长连续子串（即找到重复次数最多的子串，若有多个，输出最长的）  

 	83、长度为n的数组，有一个长度为k的滑动窗口，询问各个滑动窗口内的中位数。  

 	84、区间最大最小值。两个长度为n的序列a,b,问有多少区间[l,r] 满足max(a[l,r])<min(b[l,r])。即a[l,r]的最大值小于b[l,r]的最小值 

 	  

 	85、8皇后问题共有多少种解法  

 	86、一个数字串删除指定个数的数字字符，剩下的组成一个最大的数  

 	87、N个长度为K的有序链表合并，时间复杂度，空间复杂度  

 	88、N个长度为K的有序数组合并，时间复杂度，空间复杂度  

 	89、用一个栈去排序另一个栈  

 	90、一个数组实现两个栈  

 	91、一个n位数，现在可以删除其中任意k位，使得剩下的数最小  

 	92、实现有符号大数链表加法，靠近头结点位置为高位  

 	93、找出来数组中每个元素后边第一个比它大的值  

 	94、完全二叉树的最大深度与节点个数  

 	95、两个有序数组交集、并集  

 	96、用二分法对一个数字开根号  

 	97、一个无序有正有负数组，求乘积最大的三个数的乘积  

 	98、实现链表，无序链表，对链表值奇偶分离并排序，空间复杂度O(1)  

 	99、无序数组构建一棵二叉排序树  

 	100、打印出根节点到叶子节点的最长路径  

 	101、字符串形式自定义进制大数相加  

 	102、LeetCode  1038  

 	103、任意一个整型数组，判断是否可以将数组分为三个区间，每个区间中数值的和相同  

 	104、二叉树逆时针打印最外层节点  

 	105、无向图最短路径  

 	106、输入一个矩阵，起始点和目标点，判断是否存在可达路径