---
title: 白盒AES-tutorial 论文阅读笔记
date: 2022-03-21
categories: [白盒密码学]
tags: [白盒密码学]  
img_path: /assets/img/
---

论文原文链接 [A Tutorial on White-box AES](https://eprint.iacr.org/2013/104.pdf)

## 总体思路

Chow2002年提出的白盒AES 基本思路是将原来AES的**每一轮变换**替换为**查找表**。

**AES过程**

![image-20220318145105133](白盒tutorial笔记.assets/image-20220318145105133.png)

**白盒AES过程**

![image-20220318145147850](白盒tutorial笔记.assets/image-20220318145147850.png)

## 查找表理解

什么是查找表，查找表（Lookup Table）另一个理解就是真值表，比如下图。



![Overview of Lookup Tables (LUT) in FPGA Design - HardwareBee](白盒tutorial笔记.assets/images)

查找表的构建

- 枚举所有**输入**
- 计算出输入对应的**输出**
- 将（**输入，输出**）项插入查找表

查找表的使用

- 遍历查找表，找到**输入**相同的项
- 读取（**输入，输出**）项，返回**输出**

实际使用的时候可以优化速度，以数组index作为索引，查询复杂度为O(1)

## 具体看AES每个过程

### ShiftRows

shiftRows操作是将AES输入态矩阵进行移位操作。第一行不移动，第二行移动一列，第三行移动两列，第3行移动3列。

这一步不需要转为查找表，只需要生成查找表取数的时候，从对应移位后的矩阵中取就可以了。shiftRows 本质就是每一轮加密的输入从不同地方取值。

### AddRoundkey与SubBytes

AddRoundKey是对每一轮的输入与RoundKey做异或⊕操作。

SubBytes操作本身就是一个8进8出的查找表，将一个字节替换为另一个字节。

这两步可以合并到一个查找表中完成，称为**T-boxes**。

![image-20220318154625288](白盒tutorial笔记.assets/image-20220318154625288.png)

T-box也是一个8进8出的查找表。AES每一轮的Key有16字节，每个字节与S-box合并做一个查找表，一轮16个。AES总共10轮，所以总共需要160个T-boxes。

### MixColumns

#### T_yi tables

AES的MixColumn作用是扩散混淆，具体操作就是把**输入态**16字节矩阵左乘MC矩阵。MC矩阵是固定的。

![preview](白盒tutorial笔记.assets/v2-8453797791eb5f9b5fca6b57b6e884ec_r.jpg)

矩阵乘法可以分开按每列单独计算，因为只有同一列的数据才会互相影响。输入态的16字节矩阵可以拆开为4列，每列是4字节。

对于一列的矩阵乘法，进一步可以拆开成矩阵乘以常数，再异或相加，如下图：

![image-20220318193224673](白盒tutorial笔记.assets/image-20220318193224673.png)

因此，可以把MixCloumn操作，变为一个8进32出的一个查找表，称为**Tyi表**，计算公式如下：

![image-20220318193623042](白盒tutorial笔记.assets/image-20220318193623042.png)

之后将得到的4个Tyi表的结果做异或相加，可以得到最后的结果，完成一列4个字节的MixCloumn操作。

![image-20220318194218879](白盒tutorial笔记.assets/image-20220318194218879.png)

这样对于每一轮16个字节的输入态，就有16个Tyi查找表，总共9轮，也就是144个查找表。每个查找表是8进32出。
>这里有个疑问了，为什么不直接把整个MixCloumn操作做成查找表呢，为什么还要拆开按每行每列做一个查找表呢。
>
>原因：整个MixCloumn作为查找表，这个查找表体积会非常大。具体而言，是一个128进128出的查找表，查找表有2^128行，每一行需要128位（16字节）空间。总占用空间为2^128 * 16  byte，要知道2^32byte约为1GB，所以查找表体积完全不可接受。换一个方面来想，AES加密本身就是一个128进128出的查找表呢。
>
>采用拆开的方式，查找表是8进32出，每个查找表需要2^8 行，每行32位（4字节），体积为1KB。  共144个查找表，也就144KB。

#### XOR Table

每一列4个字节得到的4个Tyi表的需要进行异或后得到最终结果。异或操作也需要转换为查找表。

![image-20220318200144046](白盒tutorial笔记.assets/image-20220318200144046.png)

这里的异或操作也需要拆开，原本不拆开是8个字节做异或，输出4字节。查找表是32进16出，体积也会过大。拆开为8个异或表，8进4出。

异或操作理论上只需要一个查找表就够了，但因为后续章节的**保护操作**需要分开。

每一列4字节需要做3次异或，也就需要3*8个查找表，一轮有16字节就需要3 * 8 * 4 = 96个查找表。9轮共864个查找表。每个查找表是2^8 * 0.5 = 128byte。

### 表格合并

对于T-box 8进8出，Tyi 表 8进32出，这两个表可以合并变为一个表，也是8进32出，空间减少，速度更快。这个表称为**TboxTyiTable**

> 那为什么异或表不能也一起合并呢？
>
> 因为异或表的输入来自两方，如果合并，就是一个16进32出的表，大小为256kb

一轮查找表的整体流程如下

![image-20220318202821429](白盒tutorial笔记.assets/image-20220318202821429.png)

## 保护实现

首先在上述查找表实现中，查找表的生成由具体的RoundKey决定，查找表的目的就是保护RoundKey。但看具体来看每个TboxTyiTable，其保护的是RoundKey的其中一个字节（RoundKey共16字节）。

对于攻击者而言，由于一个查找表的随机性只由一字节决定，攻击者可以遍历所有可能情况（2^8次方，256种）来生成查找表，最后比对查找表就可以判断出RoundKey了。

因此需要对查找表做保护实现，具体方法如下

### Encodings

#### 保护思想

Encoding意识是编码，是对所有生成的查找表在输入输出都增加一个双射，以此把整个查找表打乱。

![image-20220320142812578](白盒tutorial笔记.assets/image-20220320142812578.png)

假设R是T的下一个查找表（即T的输出作为R的输入），那么T的输出编码和R的输入编码是互逆的（互相抵消）。

![image-20220320143041882](白盒tutorial笔记.assets/image-20220320143041882.png)

这样保证了计算结果不会因为编码而出错，同时又将查找表给编码保护了。

由于攻击者而言，查找表的生成由随机的双射和key决定。因为对于同一个查找表（假设8进），可以由256种（双射，key）对生成，攻击者因此无法确定是哪一个（双射，key）对。这样达到了信息论安全。

#### 编码链接

考虑到XOR表是从两个表的输出中各取4bit作为输入，因此要求**编码可连接**（concatenated encoding），具体如下

![image-20220320143439846](白盒tutorial笔记.assets/image-20220320143439846.png)

具体实现的时候，是随机选取长度为4bit的双射，然后将这些双射进行拼接形成长度更长的双射（如8bit，32bit）。这样形成的双射天然满足**编码可连接**的要求。

所有双射都是由长度为4bit的双射拼接而成，除了一个例外，外部编码（External encodings），这个编码可以自由选择，无需拼接，在后续第三节将介绍外部编码。

### Mixing Bijections

为了扩散混淆，在所有Key相关的表中，都加上一层随机的双射变换（Mixing bijection）。以此使得只要key稍微变化，所有生成的查找表将完全不同。

具体操作是，在TyiTboxTable前后都加上一个双射变换。TyiTboxTable是8进32出，所以在输入端加上一个8bit的逆双射-L，在输出端加上一个32bit的双射MB。类似于Encoding思想，逆双射-L用于抵消上一层L双射的影响，而逆双射-MB用于抵消本层MB的影响。

逆双射的构造由矩阵进行拆分得到，具体如下

![image-20220320160052892](白盒tutorial笔记.assets/image-20220320160052892.png)

加上Mixing Bijection后，一轮的操作如下

![简注- A Tutorial on White-box AES - improveNPC的日志](白盒tutorial笔记.assets/aes2.png)

> 疑问：为什么需要Mixing  Bijections
>
> 文章中给出的理由是：扩散混淆

### External encodings

外部编码的目的就是使得在整个加解密运行的过程中，不会出现明文。思想很简单，就是对在输入前做一次编码，输出后再做一次解码。

举例在一个知识版权软件音乐播放器，用户需要从服务器上下载付费音乐。

传统做法是：服务器下载的音乐数据是加密的，然后用户客户端上运行的音乐播放器运行解密程序，对音乐进行播放。

白盒做法是：服务器下载的音乐是经过加密以及外部编码的，用户客户端上运行的音乐播放器运行白盒解密，得到经过编码的音乐，硬件绑定的播放器对音乐解码并播放。在整个过程中，没有出现真正的明文（即音乐）。

![image-20220320164031956](白盒tutorial笔记.assets/image-20220320164031956.png)

