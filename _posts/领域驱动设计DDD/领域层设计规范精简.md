## 实体类（Entity）

### **创建即一致**

在贫血模型里，通常见到的代码是一个模型通过手动new出来之后，由调用方一个参数一个参数的赋值，这就很容易产生遗漏，导致实体状态不一致。

所以DDD里实体创建的方法有两种：

- constructor参数要包含所有必要属性，或者在constructor里有合理的默认值
- 使用Factory模式来降低调用方复杂度

### **尽量避免public setter**

一个最容易导致不一致性的原因是实体暴露了**public的setter**方法，特别是set单一参数会导致状态不一致的情况。比如，一个订单可能包含订单状态（下单、已支付、已发货、已收货）、支付单、物流单等子实体，如果一个调用方能随意去set订单状态，就有可能导致订单状态和子实体匹配不上，导致业务流程走不通的情况。

所以在实体里，需要通过行为方法来修改内部状态：比如付款（pay），发货（ship）等行为方法来修改实体状态，而不是通过setter方法由外部修改状态。

>【建议】在有些简单场景里，有时候确实可以比较随意的设置一个值而不会导致不一致性，也建议将方法名重新写为比较“行为化”的命名，会增强其语意。比如setPosition(x, y)可以叫做moveTo(x, y)，setAddress可以叫做assignAddress等。

### **通过聚合根保证主子实体的一致性**

在稍微复杂一点的领域里，通常主实体会包含子实体，这时候主实体就需要起到聚合根的作用，即：

- 子实体不能单独存在，只能通过聚合根的方法获取到。任何外部的对象都不能直接保留子实体的引用
- 子实体没有独立的Repository，不可以单独保存和取出，必须要通过聚合根的Repository实例化
- 子实体可以单独修改自身状态，但是多个子实体之间的状态一致性需要聚合根来保障

常见的电商域中聚合的案例如主子订单模型、商品/SKU模型、跨子订单优惠、跨店优惠模型等。很多聚合根和Repository的设计规范在我前面一篇关于Repository的文章中已经详细解释过，可以拿来参考。

### **不可以强依赖其他聚合根实体或领域服务**

一个实体的原则是**高内聚、低耦合**，即一个实体类不能直接在内部直接依赖一个外部的实体或服务。这个原则和绝大多数ORM框架都有比较严重的冲突，所以是一个在开发过程中需要特别注意的。这个原则的必要原因包括：一个实体无法保证外部实体变更后不会影响本实体的一致性和正确性。

正确的对外部依赖的方法有几种：

- 只保存外部实体的ID。**？**

  > 这里强烈建议使用强类型的ID对象，而不是Long型ID。强类型的ID对象不单单能自我包含验证代码，保证ID值的正确性，同时还能确保各种入参不会因为参数顺序变化而出bug。具体可以参考我的Domain Primitive文章。

- 针对于“无副作用”的外部依赖，将依赖以方法入参的方式传入。

  >方法有“副作用”的意思是，通过该方法会对外部依赖的状态进行修改。
  >
  >“无副作用”意思是，该方法不会修改外部依赖，是只读的。

- 如果方法对外部依赖有"副作用"，不能通过方法入参的方式，只能通过领域服务（Domain Service）解决。

总结为：实体的所有行为只能依赖自己的状态（数据），如果需要读取外部实体的数据，甚至修改外部实体的数据，这都应该交给领域服务完成。（Domain Service）

### **任何实体的行为只能直接影响到本实体（和其子实体）**

这条原则可以解释上面许多原则

- 尽量避免public setter
- 不可以强依赖其他聚合根实体或领域服务

这个原则更多是一个确保代码可读性、可理解的原则，即任何实体的行为不能有“直接”的”副作用“，即直接修改其他的实体类。这么做的好处是代码读下来不会产生意外。

另一个遵守的原因是可以降低未知的变更的风险。在一个系统里一个实体对象的所有变更操作应该都是预期内的，如果一个实体能随意被外部直接修改的话，会增加代码bug的风险。

## 领域服务（Domain Service）

### **单对象策略型**

这种领域对象主要面向的是**单个实体对象**的变更，但涉及到**多个领域对象或外部依赖**的一些规则和数据

- 变更的对象是单个对象
- 依赖读取其他对象的数据和规则。

实体应该通过方法入参的方式传入这种领域服务，然后通过**Double Dispatch**来反转调用领域服务的方法，即在对象内部，最好不要直接读取其他对象。

比如：

```
# 玩家装备武器
Player.equip(Weapon, EquipmentService) {
    EquipmentService.canEquip(this, Weapon); # 反转调用
}
```

为什么这种情况下不能先调用领域服务，再调用实体对象的方法呢？比如，下面这个方法是错误的：

```
boolean canEquip = EquipmentService.canEquip(Player, Weapon);
if (canEquip) {
    Player.equip(Weapon); // ❌，这种方法不可行，因为这个方法有不一致的可能性
}
```

其错误的主要原因是缺少了领域服务入参会导致方法有可能产生不一致的情况。

### **跨对象事务型**

当一个行为会**直接修改多个实体**时，不能再通过单一实体的方法作处理，而必须直接使用领域服务的方法来做操作。领域服务起到调度多个对象进行协调操作的工作。在这里，领域服务更多的起到了跨对象事务的作用，确保多个实体的变更之间是有一致性的。

这个原则也映射了“任何实体的行为只能直接影响到本实体（和其子实体）”的原则。即在对象内部，不能去修改其他对象。

### **通用组件型**

提供组件化的能力。将需要**批处理**的对象，可以让对象都获得组件，随后在统一的地方对这些组件做批处理。



## 策略对象（Domain Policy）

Policy或者Strategy设计模式是一个通用的设计模式，但是在DDD架构中会经常出现，其核心就是**封装领域规则。**

一个Policy是一个无状态的单例对象，通常需要至少2个方法：canApply 和 一个业务方法。其中，canApply方法用来判断一个Policy是否适用于当前的上下文，如果适用则调用方会去触发业务方法。通常，为了降低一个Policy的可测试性和复杂度，Policy不应该直接操作对象，而是通过返回计算后的值，在Domain Service里对对象进行操作。

## 领域事件

还有一种类型的领域规则，那就是”连锁副作用“。一般的“连锁副作用”发生在核心领域模型状态变更后，会需要同步或者异步对另一个对象的影响或行为。如果影响很多，全部写在领域服务中将异常复杂且不好维护。

### 领域事件介绍

领域事件是一个在领域里发生了某些事后，希望领域里其他对象能够感知到的通知机制。在上面的案例里，代码之所以会越来越复杂，其根本的原因是反应代码（比如升级）直接和上面的事件触发条件（比如收到经验）直接耦合，而且这种耦合性是隐性的。领域事件的好处就是将这种隐性的副作用“显性化”，通过一个显性的事件，将事件触发和事件处理解耦，最终起到代码更清晰、扩展性更好的目的。

所以，领域事件是在DDD里，比较推荐使用的跨实体“副作用”传播机制。

### 领域事件实现

和消息队列中间件不同的是，领域事件通常是立即执行的、在同一个进程内、可能是同步或异步。我们可以通过一个EventBus来实现进程内的通知机制。这可以是框架提供或者自己实现。



##  Domain Primitive

一个Value Object，同时具有清晰的业务含义和自身的行为。

### Domain Primitive的定义

**Domain Primitive是一个在特定领域里，拥有精准定义的、可自我验证的、拥有行为的Value Object**。

- DP是一个传统意义上的Value Object，拥有Immutable的特性
- DP是一个完整的概念整体，拥有精准定义
- DP使用业务域中的原生语言
- DP可以是业务域的最小组成部分、也可以构建复杂组合

Domain Primitive是Value Object的进阶版，在原始VO的基础上要求每个DP拥有概念的整体，而不仅仅是值对象。在VO的Immutable基础上增加了Validity和行为。当然同样的要求无副作用（side-effect free）。

### Domain Primitive的四点思考

- 接口的清晰度
- 数据验证和错误处理
- 业务逻辑的清晰度
- 可测试性

###  Domain Primitive 从哪里来

- Make Implicit Concepts Expecit（将**隐性概念**显性化）

  业务中、代码中有大量的隐性概念，他们潜藏在代码中。我们常常用基本类型掩盖/替换了这些概念，比如电话号码PhoneNum：String，金钱 Money：BigDecimal。我们要做的是将这些概念显性的表达出来。通常做法是创建一个单独的类Class来标识这个概念。

  >举例：业务代码经常使用String 类型来传递电话号码PhoneNum这个业务概念，然后在业务方法内部校验电话号码是否正确。
  >
  >分析：在这里电话号码这个业务概念就被**隐藏**起来了，我们需要将其**显性化**。
  >
  >1. 创建一个电话号码类Class PhoneNum，将所有与PhoneNum相关的概念和校验逻辑整理到PhoneNum类中，**分离数据验证错误处理与业务逻辑代码**，**简化真正的业务逻辑代码**。
  >
  >2. 将原先接口中的String phoneNum 替换为 PhoneNum phonNum 类型，**提升接口清晰度**。
  >
  >3. 测试时可以单独测试PhoneNum类的正确性，**大大降低测试复杂度**。

- Make Implicit Context Expecit（将 **隐性的上下文**显性化）

  >有些概念是在一个上下文中隐含的，可以将其提取出来形成一个概念。

- Encapsulate Multi-Object Behavior（封装 **多对象** 行为）

  >将多个对象的协同操作进行封装，形成一个单独的业务概念。

我们发现把隐形概念显性化之后，其实是生成了一个**Type**（数据类型）和一个**Class**（类），这个类和数据类型就是DP：

- Type指我们在今后的代码里可以通过新的数据类型去**显性的标识**原来的隐性概念
- Class指我们可以把所有跟隐性概念相关的逻辑完整的收集到一个文件里

### 常见的DP的使用场景

- 有格式限制的`String`：比如`Name`，`PhoneNumber`，`OrderNumber`，`ZipCode`，`Address`等
- 有限制的`Integer`：比如`OrderId`（>0），`Percentage`（0-100%），`Quantity`（>=0）等
- 可枚举的`int`：比如`Status`（一般不用Enum因为反序列化问题）
- `Double`或`BigDecimal`：一般用到的`Double`或`BigDecimal`都是有业务含义的，比如`Temperature`、`Money`、`Amount`、`ExchangeRate`、`Rating`等
- 复杂的数据结构：比如`Map<String, List<Integer>>`等，尽量能把`Map`的所有操作包装掉，仅暴露必要行为

## 软件设计原则

- **单一性原则**（Single Responsibility Principle）：单一性原则要求一个对象/类应该只有一个变更的原因。但是在这个案例里，代码可能会因为任意一个外部依赖或计算逻辑的改变而改变。
- **依赖反转原则**（Dependency Inversion Principle）：依赖反转原则要求在代码中依赖抽象，而不是具体的实现。在这个案例里外部依赖都是具体的实现，比如YahooForexService虽然是一个接口类，但是它对应的是依赖了Yahoo提供的具体服务，所以也算是依赖了实现。同样的KafkaTemplate、MyBatis的DAO实现都属于具体实现。
- **开放封闭原则**（Open Closed Principle）：开放封闭原则指开放扩展，但是封闭修改。在这个案例里的金额计算属于可能会被修改的代码，这个时候该逻辑应该需要被包装成为不可修改的计算类，新功能通过计算类的拓展实现。