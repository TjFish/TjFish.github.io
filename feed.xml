<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://tjfish.top//</id><title>TjFish</title><subtitle>目前同济大学软件工程学院在读研究生-研究方向密码学-兴趣方向多元.</subtitle> <updated>2023-01-05T17:10:52+08:00</updated> <author> <name>TjFish</name> <uri>https://tjfish.top//</uri> </author><link rel="self" type="application/atom+xml" href="https://tjfish.top//feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://tjfish.top//"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 TjFish </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>大型任务的多进程优化过程记录，从3个月优化到3天</title><link href="https://tjfish.top//posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/" rel="alternate" type="text/html" title="大型任务的多进程优化过程记录，从3个月优化到3天" /><published>2022-12-27T00:00:00+08:00</published> <updated>2023-01-05T16:45:14+08:00</updated> <id>https://tjfish.top//posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</id> <content src="https://tjfish.top//posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/" /> <author> <name>TjFish</name> </author> <category term="课程" /> <summary> 事情起因是这样的，一天学长找到我说:”学弟啊，你有没有空啊。现在跑机器学习实验，跑3个月结果还跑不出来，你能不能帮我优化一下代码啊？” 我心想：“一次实验跑三个月，万一写了一点bug，实验不又得重头再来三个月，这也太令人头皮发麻了吧？“ 于是我开始了实验代码优化之旅。 1.整体思路 该项目整体代码量非常多，实验室内已经维护了3~4年，整个项目构建在Pytorch上，会到大数据集进行聚类学习。一次实验涉及到的数据量很大，基本是TB级别。 仔细看了实验项目框架和执行过程，一时间没有优化思路。 问了学长，目前所有实验执行都是单核CPU，没有多线程多进程。 那优化思路不就有了——并行化，如果可以开多个进程同时跑实验，效率直接可以翻几十倍（当然最终受限于硬件资源）。 要代码并行化，要满足以下几个条件 有大量的、重复的、类似的任务，CPU密集型任务 ... </summary> </entry> <entry><title>k8s日志采集框架搭建</title><link href="https://tjfish.top//posts/k8s%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/" rel="alternate" type="text/html" title="k8s日志采集框架搭建" /><published>2022-12-06T00:00:00+08:00</published> <updated>2022-12-06T00:00:00+08:00</updated> <id>https://tjfish.top//posts/k8s%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id> <content src="https://tjfish.top//posts/k8s%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/" /> <author> <name>TjFish</name> </author> <category term="k8s" /> <summary> 学校信息办需要搭建统一的日志中心，将大部分服务的日志都迁移到日志中心上来。之前查看日志都是登录到应用部署的机器上，手动查看日志文件，很不方便。 有了日志中心后，可以在一处查看所有服务的日志，方便运维管理，快速排查问题。 这些天基于ELK+Filebeat在k8s集群上搭建了一套日志采集+日志存储+日志检索的日志中心服务，整个中间也遇到了很多问题，也学到了许多，在此做些记录。 日志采集架构 k8s官方提供了三种日志采集的解决方案，分别是节点日志采集代理，以 sidecar 容器收集日志，直接从应用程序收集日志。 节点日志采集代理 这种方案是在k8s每个节点都部署一个日志采集代理，节点上运行的容器将日志输出到文件，然后日志采集代理分析收集日志文件，并发送给远端的日志系统，比如Elasticsearch。 常见的日志采集代理有Logstash，Filebeat，Flunetd... </summary> </entry> <entry><title>Raft分布式一致性协议的实现思路</title><link href="https://tjfish.top//posts/MIT%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/" rel="alternate" type="text/html" title="Raft分布式一致性协议的实现思路" /><published>2022-11-03T00:00:00+08:00</published> <updated>2023-01-05T17:10:23+08:00</updated> <id>https://tjfish.top//posts/MIT%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</id> <content src="https://tjfish.top//posts/MIT%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/" /> <author> <name>TjFish</name> </author> <category term="分布式" /> <summary> 暑期的时候参加了麻省理工大学的分布式系统课程（MIT 6.824 ），其中的课程实验要求实现Raft分布式一致性协议，一致性协议的应用是为了维护各节点数据的一致性，换句话说，就是使集群里的节点存储的数据是一模一样的。实现Raft协议后，需要在此基础上实现基于Raft的kv数据库。 项目开发语言是GO，之前并没有接触过，也顺便跟着课程实验学一学。 目前已经完成了前三个课程实验，实现了一个基于Raft的分布式KV数据库。 实现代码已经开源，项目地址：https://github.com/TjFish/MIT-6.824-2022 已完成内容如下： lab1 MapReduce lab2 Raft 2A leader election 2B log 2C persistence 2D log compaction... </summary> </entry> <entry><title>领域驱动设计学习总结与记录</title><link href="https://tjfish.top//posts/DDD%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="alternate" type="text/html" title="领域驱动设计学习总结与记录" /><published>2022-10-18T00:00:00+08:00</published> <updated>2023-01-05T16:45:14+08:00</updated> <id>https://tjfish.top//posts/DDD%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id> <content src="https://tjfish.top//posts/DDD%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" /> <author> <name>TjFish</name> </author> <category term="领域驱动设计DDD" /> <summary> 下面的文章是我看过后，非常推荐的领域驱动设计文章，值得用心学习记录。 领域驱动设计学习总结与记录 详解DDD系列 第一讲 - Domain Primitive 详解DDD系列 第二讲 - 应用架构 详解DDD系列 第三讲 - Repository模式 详解DDD系列 第四讲 - 领域层设计规范 详解DDD系列 第五讲 - 聊聊如何避免写流水账代码 结合电商支付业务一文搞懂DDD CQRS与EventSourcing的架构设计 设计模式-何时使用继承？详细了解装饰器模式 设计模式-策略模式，封装复杂的领域知识 领域驱动设计的概念 软件开发不是一蹴而就的事情，我们不可能在不了解产品(或行业领域)的前提下进行软件开发，在开发前通常需要进行大量的业务知识梳理，然后才能到软件设计的层面，最后才是开发。而在业务知识梳理... </summary> </entry> <entry><title>《clean code》读后感</title><link href="https://tjfish.top//posts/clean-code%E8%AF%BB%E5%90%8E%E6%84%9F/" rel="alternate" type="text/html" title="《clean code》读后感" /><published>2022-10-06T00:00:00+08:00</published> <updated>2022-10-06T00:00:00+08:00</updated> <id>https://tjfish.top//posts/clean-code%E8%AF%BB%E5%90%8E%E6%84%9F/</id> <content src="https://tjfish.top//posts/clean-code%E8%AF%BB%E5%90%8E%E6%84%9F/" /> <author> <name>TjFish</name> </author> <category term="领域驱动设计DDD" /> <summary> 读完《clean code》一书，有些想法，想要记录下来。 《clean code》在一年前字节实习的时候就听同事推荐过，但一直没有下决心来看。本学期软件建模课程的刘岩老师又一次提起了它，在第一节课上，她提了两本书建议我们看看：《Domain Driven Design》和《clean code》。第一本书是关于领域驱动设计的，我看过后备受启发。这本书打开了我对面向对象的大门，让我发现了我之前写的代码（MVC）不过是一堆贫血模型和CRUD。本文不是谈DDD的，因此对《Domain Driven Design》也就点到为止。对于《clean code》，我在开始看前的刻板印象都是些繁碎教条，就像每个项目都有的《编码风格规范》一样。然而因为第一本书《DDD》的巨大“成功”，我开始尝试看《clean code》。 相较于《Domain Driven Design》从宏观的、架构角度去谈... </summary> </entry> </feed>
